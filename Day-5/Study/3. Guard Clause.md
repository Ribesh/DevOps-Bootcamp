# Guard Clauses

**Guard clauses** are a proven pattern in Shell scripting **to handle error cases upfront**—exiting when preconditions aren’t met—so that the main logic remains flat, readable, and maintainable. 
>By bailing out early on failures, you avoid deeply nested conditionals and reduce the risk of bugs.

### 1. Simple if-else Example
```bash
#!/bin/bash
# Check if a file exists
if [[ -e myfile.txt ]]; then
    echo "File exists"
else
    echo "File does not exist"
fi
```

### 2. The Pitfall of Nested Conditionals
```bash
#!/bin/bash
# Bad example: many nested checks
if [[ "${USER_NAME}" == "admin" ]]; then
    if [[ -e "${FILE_PATH}" ]]; then
        if [[ -s "${FILE_PATH}" ]]; then
            run_process
        else
            echo "File exists but is empty"
        fi
    else
        echo "File does not exist"
    fi
else
    echo "User is not admin"
fi
exit 0
```

### 3. Refactoring with Guard Clauses
> First, declare constants and helper functions:

```bash
#!/bin/bash
readonly FILE_PATH="/home/ubuntu/guard_clause/file.txt"
readonly USER_NAME="admin"

run_process() {
    echo "running process..."
}
```

>Next, validate each precondition at the top. Exit immediately on failure:
```bash
#!/bin/bash
readonly FILE_PATH="/home/ubuntu/guard_clause/file.txt"
readonly USER_NAME="admin"


run_process() {
    echo "running process..."
}


# Guard clauses
if [[ "${USER_NAME}" != "admin" ]]; then
    echo "User is not admin"
    exit 1
fi


if [[ ! -e "${FILE_PATH}" ]]; then
    echo "File does not exist"
    exit 1
fi


if [[ ! -s "${FILE_PATH}" ]]; then
    echo "File exists but is empty"
    exit 1
fi


# Main logic
run_process
exit 0
```
> Notice how each check uses a negative test (!=, ! -e, ! -s) to bail out early. Only when all conditions pass does the script reach run_process.

### 4. Guard Clause for Command-Line Arguments
```bash
#!/bin/bash
# Bail out if no argument is supplied

if [[ -z ${1} ]]; then
    echo "Usage: $0 <git-repo-url>"
    exit 1
fi


git_url="${1}"


clone_git() {
    git clone "${git_url}"
}

clone_git
exit 0
```

### 5. One-Line Guard Clauses with Logical Operators
Bash’s `&& `and `||` allow you to write compact guard clauses:

-  **OR** `(||)`: Execute the right side if the left side fails
    ```bash
    [[ -f "file.txt" ]] || echo "file does not exist"
    ```

-   **AND** `(&&)`: Execute the right side if the left side succeeds
    ```bash
    [[ -z ${1} ]] && echo "argument empty"
    ```

- To include an `exit` in a one-liner, group commands with `{ …; }`:
    ```bash
    [[ -f "file.txt" ]] || { echo "file does not exist"; exit 1; }
    ```

![alt text](image-2.png)

---

```bash
#!/bin/bash
project="${1}"
branch="${2}"

#HERE 
if [[ -z "${project}" ]]; then
   echo "Error: Git project not specified"
   exit 1
fi

project_dir="$(basename ${project} .git)"

clone_project() {
  if [ ! -d "/home/bob/git/${project_dir}" ]; then
    cd /home/bob/git/
    git clone "${project}"
  fi
}

git_checkout() {
  cd  "/home/bob/git/${project_dir}"
  
  #HERE
  if [[ ! -z "${branch}" ]]; then
    git checkout "${branch}" ||  { echo "Error: Branch ${branch} doesn't exist in ${project}."; exit 1; }
  fi
}

find_files() {
  find . -type f | wc -l
}
clone_project
git_checkout
find_files
```